"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var locale_1 = require("./locale");
var LETTERS = new Map([
    ['a', 'α'],
    ['b', 'ḅ'],
    ['c', 'ͼ'],
    ['d', 'ḍ'],
    ['e', 'ḛ'],
    ['f', 'ϝ'],
    ['g', 'ḡ'],
    ['h', 'ḥ'],
    ['i', 'ḭ'],
    ['j', 'ĵ'],
    ['k', 'ḳ'],
    ['l', 'ḽ'],
    ['m', 'ṃ'],
    ['n', 'ṇ'],
    ['o', 'ṓ'],
    ['p', 'ṗ'],
    ['q', 'ʠ'],
    ['r', 'ṛ'],
    ['s', 'ṡ'],
    ['t', 'ṭ'],
    ['u', 'ṵ'],
    ['v', 'ṽ'],
    ['w', 'ẁ'],
    ['x', 'ẋ'],
    ['y', 'ẏ'],
    ['z', 'ẓ'],
    ['A', 'Ḁ'],
    ['B', 'Ḃ'],
    ['C', 'Ḉ'],
    ['D', 'Ḍ'],
    ['E', 'Ḛ'],
    ['F', 'Ḟ'],
    ['G', 'Ḡ'],
    ['H', 'Ḥ'],
    ['I', 'Ḭ'],
    ['J', 'Ĵ'],
    ['K', 'Ḱ'],
    ['L', 'Ḻ'],
    ['M', 'Ṁ'],
    ['N', 'Ṅ'],
    ['O', 'Ṏ'],
    ['P', 'Ṕ'],
    ['Q', 'Ǫ'],
    ['R', 'Ṛ'],
    ['S', 'Ṣ'],
    ['T', 'Ṫ'],
    ['U', 'Ṳ'],
    ['V', 'Ṿ'],
    ['W', 'Ŵ'],
    ['X', 'Ẋ'],
    ['Y', 'Ŷ'],
    ['Z', 'Ż'],
]);
var DEFAULT_RATIO = 1.15;
var LOCALE_RATIOS = new Map([
    ['zh', 0.5],
    ['ja', 0.5],
    ['ko', 0.8],
    ['fr', 1.3],
    ['it', 1.3],
    ['de', 1.5],
    ['nl', 1.5],
]);
function sizeRatio(_a) {
    var locale = _a.to;
    if (locale == null) {
        return DEFAULT_RATIO;
    }
    return (LOCALE_RATIOS.get(locale) ||
        LOCALE_RATIOS.get(locale_1.languageFromLocale(locale)) ||
        DEFAULT_RATIO);
}
exports.sizeRatio = sizeRatio;
function pseudotranslate(string, _a) {
    var _b = _a === void 0 ? {} : _a, delimiter = _b.delimiter, _c = _b.startDelimiter, startDelimiter = _c === void 0 ? delimiter : _c, _d = _b.endDelimiter, endDelimiter = _d === void 0 ? delimiter : _d, prepend = _b.prepend, append = _b.append, toLocale = _b.toLocale;
    var parts = createParts(string, { startDelimiter: startDelimiter, endDelimiter: endDelimiter });
    var adjustableCharacters = parts.reduce(function (sum, part) {
        return typeof part === 'string' ? sum + countAdjustableCharacters(part) : sum;
    }, 0);
    var charactersToAdjust = Math.ceil(adjustableCharacters * sizeRatio({ to: toLocale })) -
        adjustableCharacters;
    var adjustEvery = adjustableCharacters / Math.abs(charactersToAdjust);
    var adjustAt = adjustEvery;
    var adjustableCharacterIndex = -1;
    var pseudotranslated = parts.reduce(function (pseudotranslated, part) {
        var pseudotranslatedPart = typeof part === 'string'
            ? tslib_1.__spread(part).map(function (character) {
                var isAdjustable = isAdjustableCharacter(character);
                if (isAdjustable) {
                    adjustableCharacterIndex++;
                }
                var newCharacter = LETTERS.get(character) || character;
                var shouldAdjust = isAdjustable &&
                    adjustableCharacterIndex + 1 === Math.floor(adjustAt);
                if (shouldAdjust) {
                    adjustAt += adjustEvery;
                    return charactersToAdjust < 0 ? '' : newCharacter.repeat(2);
                }
                else {
                    return newCharacter;
                }
            })
                .join('')
            : part[0];
        return pseudotranslated + pseudotranslatedPart;
    }, '');
    return "" + (prepend || '') + pseudotranslated + (append || '');
}
exports.pseudotranslate = pseudotranslate;
function isAdjustableCharacter(character) {
    return LETTERS.has(character);
}
function countAdjustableCharacters(string) {
    return tslib_1.__spread(string).filter(isAdjustableCharacter).length;
}
function createParts(string, _a) {
    var startDelimiter = _a.startDelimiter, endDelimiter = _a.endDelimiter;
    var delimiterRegex = startDelimiter && endDelimiter
        ? createDelimiterRegex(startDelimiter, endDelimiter)
        : undefined;
    var lastTokenEndIndex = 0;
    var parts = [];
    if (delimiterRegex) {
        var token = delimiterRegex.exec(string);
        while (token) {
            parts.push(string.substring(lastTokenEndIndex, token.index));
            parts.push(token);
            lastTokenEndIndex = token.index + token[0].length;
            token = delimiterRegex.exec(string);
        }
    }
    else {
        parts.push(string);
    }
    return parts;
}
function createDelimiterRegex(startDelimiter, endDelimiter) {
    if (startDelimiter.length === 1 && endDelimiter.length === 1) {
        return new RegExp("\\" + startDelimiter + "[^\\" + endDelimiter + "]*\\" + endDelimiter, 'g');
    }
    var escapedStart = tslib_1.__spread(startDelimiter).map(function (character) { return "\\" + character; })
        .join('');
    var escapedEnd = tslib_1.__spread(endDelimiter).map(function (character) { return "\\" + character; })
        .join('');
    return new RegExp(escapedStart + ".*?" + escapedEnd, 'g');
}
