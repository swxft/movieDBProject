"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var intl = new Map();
function memoizedGetDateTimeFormat(locales, options) {
    var key = dateTimeFormatCacheKey(locales, options);
    if (intl.has(key)) {
        return intl.get(key);
    }
    var i = new Intl.DateTimeFormat(locales, options);
    intl.set(key, i);
    return i;
}
exports.memoizedGetDateTimeFormat = memoizedGetDateTimeFormat;
var browserFeatureDetectionDate = Intl.DateTimeFormat('en', {
    hour: 'numeric',
});
var resolvedOptions = typeof browserFeatureDetectionDate.resolvedOptions === 'undefined'
    ? undefined
    : browserFeatureDetectionDate.resolvedOptions();
function formatDate(date, locales, options) {
    if (options === void 0) { options = {}; }
    var hourCycleRequired = resolvedOptions != null &&
        options.hour12 === false &&
        resolvedOptions.hourCycle != null;
    if (hourCycleRequired) {
        options.hour12 = undefined;
        options.hourCycle = 'h23';
    }
    // Etc/GMT+12 is not supported in most browsers and there is no equivalent fallback
    if (options.timeZone != null && options.timeZone === 'Etc/GMT+12') {
        var adjustedDate = new Date(date.valueOf() - 12 * 60 * 60 * 1000);
        return memoizedGetDateTimeFormat(locales, tslib_1.__assign(tslib_1.__assign({}, options), { timeZone: 'UTC' })).format(adjustedDate);
    }
    return memoizedGetDateTimeFormat(locales, options).format(date);
}
exports.formatDate = formatDate;
function dateTimeFormatCacheKey(locales, options) {
    if (options === void 0) { options = {}; }
    var localeKey = Array.isArray(locales) ? locales.sort().join('-') : locales;
    return localeKey + "-" + JSON.stringify(options);
}
exports.dateTimeFormatCacheKey = dateTimeFormatCacheKey;
