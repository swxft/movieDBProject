function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { matcherHint, printReceived, printExpected, RECEIVED_COLOR as receivedColor } from 'jest-matcher-utils';
import { assertIsNode, diffPropsForNode } from './utilities';
export function toHaveReactProps(node, props) {
  var _this = this;

  assertIsNode(node, {
    expectation: 'toHaveReactProps',
    isNot: this.isNot
  });

  if (props == null || _typeof(props) !== 'object') {
    return {
      pass: false,
      message: function message() {
        return "You passed ".concat(props == null ? String(props) : "a ".concat(_typeof(props)), " as props, but it must be an object.");
      }
    };
  }

  var pass = Object.keys(props).every(function (key) {
    return _this.equals(props[key], node.props[key]);
  });
  var message = pass ? function () {
    return "".concat(matcherHint('.not.toHaveReactProps', node.toString()), "\n\n") + "Expected the React element:\n  ".concat(receivedColor(node.toString()), "\n") + "Not to have props:\n  ".concat(printExpected(props), "\n") + "Received:\n  ".concat(printReceived(node.props), "\n");
  } : function () {
    var diffString = diffPropsForNode(node, props, {
      expand: _this.expand
    });
    return "".concat(matcherHint('.toHaveReactProps', node.toString()), "\n\n") + "Expected the React element:\n  ".concat(receivedColor(node.toString()), "\n") + "To have props:\n  ".concat(printExpected(props), "\n") + "Received:\n  ".concat(printReceived(node.props), "\n").concat(diffString ? "Difference:\n".concat(diffString, "\n") : '');
  };
  return {
    pass: pass,
    message: message
  };
}
export function toHaveReactDataProps(node, data) {
  return toHaveReactProps.call(this, node, data);
}