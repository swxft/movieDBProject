function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { diff, matcherErrorMessage, matcherHint, RECEIVED_COLOR as receivedColor, printWithType, printReceived, printExpected } from 'jest-matcher-utils';
import { Root } from '../root';
import { Element } from '../element';
export function assertIsNode(node, _ref) {
  var expectation = _ref.expectation,
      isNot = _ref.isNot;

  if (node == null) {
    throw new Error(matcherErrorMessage(matcherHint(".".concat(expectation), undefined, undefined, {
      isNot: isNot
    }), "".concat(receivedColor('received'), " value must be an @shopify/react-testing Root or Element object"), "Received ".concat(receivedColor('null'), ".\nThis usually means that your `.findX` method failed to find any matching elements.")));
  }

  if (Array.isArray(node) && node.length > 1 && (node[0] instanceof Root || node[0] instanceof Element)) {
    throw new Error(matcherErrorMessage(matcherHint(".".concat(expectation), undefined, undefined, {
      isNot: isNot
    }), "".concat(receivedColor('received'), " value must be an @shopify/react-testing Root or Element object"), "Received an ".concat(receivedColor('array of Root or Element objects'), ".\nThis usually means that you passed in the result of `.findAllX`. Pass the result of `.findX` instead.")));
  }

  if (!(node instanceof Root) && !(node instanceof Element)) {
    throw new Error(matcherErrorMessage(matcherHint(".".concat(expectation), undefined, undefined, {
      isNot: isNot
    }), "".concat(receivedColor('received'), " value must be an @shopify/react-testing Root or Element object"), printWithType('Received', node, printReceived)));
  }
}
export function assertIsType(type, _ref2) {
  var expectation = _ref2.expectation,
      isNot = _ref2.isNot;

  if (type == null) {
    throw new Error(matcherErrorMessage(matcherHint(".".concat(expectation), undefined, undefined, {
      isNot: isNot
    }), "".concat(receivedColor('expected'), " value must be a string or a valid React component."), printWithType('Expected', type, printExpected)));
  }
}
export function diffs(element, props, expand) {
  return element.reduce(function (diffs, element, index) {
    var separator = index === 0 ? '' : '\n\n';
    return "".concat(diffs).concat(separator).concat(normalizedDiff(element, props, {
      expand: expand,
      showLegend: index === 0
    }));
  }, '');
}

function normalizedDiff(element, props, _ref3) {
  var _ref3$expand = _ref3.expand,
      expand = _ref3$expand === void 0 ? false : _ref3$expand,
      _ref3$showLegend = _ref3.showLegend,
      showLegend = _ref3$showLegend === void 0 ? false : _ref3$showLegend;
  var result = diffPropsForNode(element, props, {
    expand: expand
  }) || '';
  return showLegend ? result : result.split('\n\n')[1];
}

export function printType(type) {
  if (_typeof(type) === 'object' && '_context' in type) {
    var context = type._context;
    var componentName = type === context.Provider ? 'Provider' : 'Consumer';

    var _displayName = context.displayName || 'Context';

    return "<".concat(_displayName, ".").concat(componentName, " />");
  }

  var displayName = typeof type === 'string' ? type : type.displayName || type.name || 'Component';
  return "<".concat(displayName, " />");
}
export function diffPropsForNode(node, props, _ref4) {
  var _ref4$expand = _ref4.expand,
      expand = _ref4$expand === void 0 ? false : _ref4$expand;
  return diff(props, getObjectSubset(node.props, props), {
    expand: expand
  });
} // Original from https://github.com/facebook/jest/blob/master/packages/expect/src/utils.ts#L107

function getObjectSubset(object, subset) {
  if (Array.isArray(object)) {
    if (Array.isArray(subset) && subset.length === object.length) {
      return subset.map(function (sub, i) {
        return getObjectSubset(object[i], sub);
      });
    }
  } else if (object instanceof Date) {
    return object;
  } else if (_typeof(object) === 'object' && object !== null && _typeof(subset) === 'object' && subset !== null) {
    var trimmed = {};
    Object.keys(subset).filter(function (key) {
      return Reflect.has(object, key);
    }).forEach(function (key) {
      return trimmed[key] = getObjectSubset(object[key], subset[key]);
    });

    if (Object.keys(trimmed).length > 0) {
      return trimmed;
    }
  }

  return object;
}

export function pluralize(word, count) {
  return count === 1 ? word : "".concat(word, "s");
}