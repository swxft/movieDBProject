import React from 'react';
import { render, unmountComponentAtNode } from 'react-dom';
import { act } from 'react-dom/test-utils';
import { TestWrapper } from './TestWrapper';
import { Element } from './element';
import { Tag } from './types'; // eslint-disable-next-line @typescript-eslint/no-var-requires

const {
  findCurrentFiberUsingSlowPath
} = require('react-reconciler/reflection');

export const connected = new Set();
export class Root {
  get props() {
    return this.withRoot(root => root.props);
  }

  get isDOM() {
    return this.withRoot(root => root.isDOM);
  }

  get type() {
    return this.withRoot(root => root.type);
  }

  get instance() {
    return this.withRoot(root => root.instance);
  }

  get children() {
    return this.withRoot(root => root.children);
  }

  get descendants() {
    return this.withRoot(root => root.descendants);
  }

  get domNodes() {
    return this.withRoot(root => root.domNodes);
  }

  get domNode() {
    return this.withRoot(root => root.domNode);
  }

  get mounted() {
    return this.wrapper != null;
  }

  constructor(tree, {
    render = defaultRender,
    resolveRoot = defaultResolveRoot
  } = {}) {
    this.tree = tree;
    this.wrapper = null;
    this.element = document.createElement('div');
    this.root = null;
    this.acting = false;
    this.render = void 0;
    this.resolveRoot = void 0;
    this.render = render;
    this.resolveRoot = resolveRoot;
    this.mount();
  }

  act(action, {
    update = true
  } = {}) {
    const updateWrapper = update ? this.update.bind(this) : noop;
    let result;

    if (this.acting) {
      return action();
    }

    this.acting = true;

    const afterResolve = () => {
      updateWrapper();
      this.acting = false;
      return result;
    };

    const promise = act(() => {
      result = action(); // This condition checks the returned value is an actual Promise and returns it
      // to Reactâ€™s `act()` call, otherwise we just want to return `undefined`

      if (isPromise(result)) {
        return result;
      }

      return undefined;
    });

    if (isPromise(result)) {
      updateWrapper();
      return Promise.resolve(promise).then(afterResolve);
    }

    return afterResolve();
  }

  html() {
    return this.withRoot(root => root.html());
  }

  text() {
    return this.withRoot(root => root.text());
  }

  is(type) {
    return this.withRoot(root => root.is(type));
  }

  prop(key) {
    return this.withRoot(root => root.prop(key));
  }

  data(key) {
    return this.withRoot(root => root.data(key));
  }

  find(type, props) {
    return this.withRoot(root => root.find(type, props));
  }

  findAll(type, props) {
    return this.withRoot(root => root.findAll(type, props));
  }

  findWhere(predicate) {
    return this.withRoot(root => root.findWhere(predicate));
  }

  findAllWhere(predicate) {
    return this.withRoot(root => root.findAllWhere(predicate));
  }

  trigger(prop, ...args) {
    return this.withRoot(root => root.trigger(prop, ...args));
  }

  triggerKeypath(keypath, ...args) {
    return this.withRoot(root => root.triggerKeypath(keypath, ...args));
  }

  mount() {
    if (this.mounted) {
      throw new Error('Attempted to mount a node that was already mounted');
    }

    if (this.element.parentNode == null) {
      document.body.appendChild(this.element);
      connected.add(this);
    }

    this.act(() => {
      render( /*#__PURE__*/React.createElement(TestWrapper, {
        render: this.render,
        ref: wrapper => {
          this.wrapper = wrapper;
        }
      }, this.tree), this.element);
    });
  }

  unmount() {
    if (!this.mounted) {
      throw new Error('You attempted to unmount a node that was already unmounted');
    }

    this.ensureRoot();
    this.act(() => unmountComponentAtNode(this.element));
  }

  destroy() {
    const {
      element,
      mounted
    } = this;

    if (mounted) {
      this.unmount();
    }

    element.remove();
    connected.delete(this);
  }

  setProps(props) {
    this.ensureRoot();
    this.act(() => this.wrapper.setProps(props));
  }

  forceUpdate() {
    this.ensureRoot();
    this.act(() => this.wrapper.forceUpdate());
  }

  debug(options) {
    this.ensureRoot();
    return this.root.debug(options);
  }

  toString() {
    return this.withRoot(root => root.toString());
  }

  update() {
    if (this.wrapper == null) {
      this.root = null;
    } else {
      const topElement = flatten(this.wrapper._reactInternalFiber, this)[0];
      this.root = this.resolveRoot(topElement);
    }
  }

  ensureRoot() {
    if (this.wrapper == null || this.root == null) {
      throw new Error('Attempted to operate on a mounted tree, but the component is no longer mounted');
    }
  }

  withRoot(withRoot) {
    this.ensureRoot();
    return withRoot(this.root);
  }

}

function defaultResolveRoot(element) {
  return element.children[0];
}

function defaultRender(element) {
  return element;
}

function flatten(element, root) {
  const node = findCurrentFiberUsingSlowPath(element);

  if (node.tag === Tag.HostText) {
    return [node.memoizedProps];
  }

  const props = { ...(node.memoizedProps || {})
  };
  const {
    children,
    descendants
  } = childrenToTree(node.child, root);
  return [new Element({
    tag: node.tag,
    type: node.type,
    props,
    instance: node.stateNode
  }, children, descendants, root), ...descendants];
}

function childrenToTree(fiber, root) {
  let currentFiber = fiber;
  const children = [];
  const descendants = [];

  while (currentFiber != null) {
    const result = flatten(currentFiber, root);

    if (result.length > 0) {
      children.push(result[0]);
      descendants.push(...result);
    }

    currentFiber = currentFiber.sibling;
  }

  return {
    children,
    descendants
  };
}

function isPromise(promise) {
  return promise != null && typeof promise === 'object' && 'then' in promise;
}

function noop() {}