"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = require("react");
var apollo_client_1 = tslib_1.__importDefault(require("./apollo-client"));
function useBackgroundQuery(load, options) {
    var _this = this;
    var client = apollo_client_1.default();
    var lastClient = react_1.useRef(client);
    var lastOptions = react_1.useRef(options);
    var serializedOptions = JSON.stringify(options);
    var lastSerializedOptions = react_1.useRef(serializedOptions);
    var subscription = react_1.useRef(null);
    var polling = react_1.useRef(Boolean(options && options.pollInterval));
    if (subscription.current != null &&
        (lastClient.current !== client ||
            lastSerializedOptions.current !== serializedOptions)) {
        subscription.current.unsubscribe();
        subscription.current = null;
    }
    lastClient.current = client;
    lastOptions.current = options;
    lastSerializedOptions.current = serializedOptions;
    react_1.useEffect(function () { return function () {
        if (subscription.current) {
            subscription.current.unsubscribe();
            subscription.current = null;
        }
    }; }, []);
    return react_1.useCallback(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var query, observableQuery, unsubscribe;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (subscription.current) {
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, load()];
                case 1:
                    query = _a.sent();
                    if (query == null || query instanceof Error) {
                        return [2 /*return*/];
                    }
                    observableQuery = lastClient.current.watchQuery(tslib_1.__assign({ query: query, fetchPolicy: 'network-only' }, lastOptions.current));
                    unsubscribe = function () {
                        if (polling.current || subscription.current == null) {
                            return;
                        }
                        subscription.current.unsubscribe();
                        subscription.current = null;
                    };
                    subscription.current = observableQuery.subscribe(unsubscribe, unsubscribe);
                    return [2 /*return*/];
            }
        });
    }); }, [load]);
}
exports.useBackgroundQuery = useBackgroundQuery;
