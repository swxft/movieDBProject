"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var graphql_testing_1 = require("@shopify/graphql-testing");
var react_testing_1 = require("@shopify/react-testing");
var ApolloProvider_1 = require("../../ApolloProvider");
var createGraphQL = graphql_testing_1.createGraphQLFactory();
exports.mountWithGraphQL = react_testing_1.createMount({
    context: function (_a) {
        var _b = _a.graphQL, graphQL = _b === void 0 ? createGraphQL() : _b;
        return { graphQL: graphQL };
    },
    render: function (element, _a) {
        var graphQL = _a.graphQL;
        return react_1.default.createElement(ApolloProvider_1.ApolloProvider, { client: graphQL.client }, element);
    },
    afterMount: function (root, _a) {
        var skipInitialGraphQL = _a.skipInitialGraphQL;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var graphQL;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        graphQL = root.context.graphQL;
                        graphQL.wrap(function (perform) { return root.act(perform); });
                        if (skipInitialGraphQL) {
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, graphQL.resolveAll()];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    },
});
function createResolvablePromise(value) {
    var _this = this;
    var resolver;
    var rejecter;
    var promise = new Promise(function (resolve, reject) {
        resolver = function () {
            resolve(value);
            return promise;
        };
        rejecter = reject;
    });
    return {
        resolve: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var value;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, resolver()];
                    case 1:
                        value = _a.sent();
                        // If we just resolve, the tick that actually processes the promise
                        // has not finished yet.
                        return [4 /*yield*/, new Promise(function (resolve) { return process.nextTick(resolve); })];
                    case 2:
                        // If we just resolve, the tick that actually processes the promise
                        // has not finished yet.
                        _a.sent();
                        return [2 /*return*/, value];
                }
            });
        }); },
        reject: rejecter,
        promise: promise,
    };
}
exports.createResolvablePromise = createResolvablePromise;
