"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var dates_1 = require("@shopify/dates");
var decorators_1 = require("@shopify/decorators");
var i18n_1 = require("@shopify/i18n");
var types_1 = require("./types");
var constants_1 = require("./constants");
var errors_1 = require("./errors");
var utilities_1 = require("./utilities");
// Used for currecies that don't use fractional units (eg. JPY)
var DECIMAL_NOT_SUPPORTED = 'N/A';
var PERIOD = '.';
var DECIMAL_VALUE_FOR_CURRENCIES_WITHOUT_DECIMALS = '00';
var I18n = /** @class */ (function () {
    function I18n(translations, _a) {
        var _this = this;
        var locale = _a.locale, currency = _a.currency, timezone = _a.timezone, country = _a.country, _b = _a.pseudolocalize, pseudolocalize = _b === void 0 ? false : _b, onError = _a.onError, loading = _a.loading;
        this.translations = translations;
        this.getCurrencySymbol = function (currencyCode) {
            var currency = currencyCode || _this.defaultCurrency;
            if (currency == null) {
                throw new errors_1.MissingCurrencyCodeError('formatCurrency cannot be called without a currency code.');
            }
            return _this.getCurrencySymbolLocalized(_this.locale, currency);
        };
        this.locale = locale;
        this.defaultCountry = country;
        this.defaultCurrency = currency;
        this.defaultTimezone = timezone;
        this.pseudolocalize = pseudolocalize;
        this.onError = onError || defaultOnError;
        this.loading = loading || false;
    }
    Object.defineProperty(I18n.prototype, "language", {
        get: function () {
            return i18n_1.languageFromLocale(this.locale);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I18n.prototype, "region", {
        get: function () {
            return i18n_1.regionFromLocale(this.locale);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I18n.prototype, "countryCode", {
        /**
         * @deprecated Use I18n#region instead.
         */
        get: function () {
            return i18n_1.regionFromLocale(this.locale);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I18n.prototype, "languageDirection", {
        get: function () {
            return constants_1.RTL_LANGUAGES.includes(this.language)
                ? types_1.LanguageDirection.Rtl
                : types_1.LanguageDirection.Ltr;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I18n.prototype, "isRtlLanguage", {
        get: function () {
            return this.languageDirection === types_1.LanguageDirection.Rtl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(I18n.prototype, "isLtrLanguage", {
        get: function () {
            return this.languageDirection === types_1.LanguageDirection.Ltr;
        },
        enumerable: true,
        configurable: true
    });
    I18n.prototype.translate = function (id, optionsOrReplacements, replacements) {
        var pseudolocalize = this.pseudolocalize;
        var normalizedOptions;
        if (optionsOrReplacements == null) {
            normalizedOptions = { pseudotranslate: pseudolocalize };
        }
        else if (isTranslateOptions(optionsOrReplacements)) {
            normalizedOptions = tslib_1.__assign(tslib_1.__assign({}, optionsOrReplacements), { replacements: replacements, pseudotranslate: pseudolocalize });
        }
        else {
            normalizedOptions = {
                replacements: optionsOrReplacements,
                pseudotranslate: pseudolocalize,
            };
        }
        try {
            return utilities_1.translate(id, normalizedOptions, this.translations, this.locale);
        }
        catch (error) {
            this.onError(error);
            return '';
        }
    };
    I18n.prototype.getTranslationTree = function (id, replacements) {
        try {
            if (!replacements) {
                return utilities_1.getTranslationTree(id, this.translations, this.locale);
            }
            return utilities_1.getTranslationTree(id, this.translations, this.locale, replacements);
        }
        catch (error) {
            this.onError(error);
            return '';
        }
    };
    I18n.prototype.translationKeyExists = function (id) {
        try {
            utilities_1.getTranslationTree(id, this.translations, this.locale);
            return true;
        }
        catch (error) {
            return false;
        }
    };
    I18n.prototype.formatNumber = function (amount, _a) {
        if (_a === void 0) { _a = {}; }
        var as = _a.as, precision = _a.precision, options = tslib_1.__rest(_a, ["as", "precision"]);
        var _b = this, locale = _b.locale, currency = _b.defaultCurrency;
        if (as === 'currency' && currency == null && options.currency == null) {
            this.onError(new errors_1.MissingCurrencyCodeError("formatNumber(amount, {as: 'currency'}) cannot be called without a currency code."));
            return '';
        }
        return utilities_1.memoizedNumberFormatter(locale, tslib_1.__assign({ style: as, maximumFractionDigits: precision, currency: currency }, options)).format(amount);
    };
    I18n.prototype.unformatNumber = function (input) {
        var _a = this.numberSymbols(), thousandSymbol = _a.thousandSymbol, decimalSymbol = _a.decimalSymbol;
        var normalizedValue = normalizedNumber(input, decimalSymbol, thousandSymbol === PERIOD);
        return normalizedValue === '' ? '' : parseFloat(normalizedValue).toString();
    };
    I18n.prototype.formatCurrency = function (amount, _a) {
        if (_a === void 0) { _a = {}; }
        var form = _a.form, options = tslib_1.__rest(_a, ["form"]);
        switch (form) {
            case 'auto':
                return this.formatCurrencyAuto(amount, options);
            case 'explicit':
                return this.formatCurrencyExplicit(amount, options);
            case 'short':
                return this.formatCurrencyShort(amount, options);
        }
        return this.formatNumber(amount, tslib_1.__assign({ as: 'currency' }, options));
    };
    I18n.prototype.unformatCurrency = function (input, currencyCode) {
        // This decimal symbol will always be '.' regardless of the locale
        // since it's our internal representation of the string
        var decimalSymbol = this.currencyDecimalSymbol(currencyCode);
        var expectedDecimalSymbol = decimalSymbol === DECIMAL_NOT_SUPPORTED ? PERIOD : decimalSymbol;
        var normalizedValue = normalizedNumber(input, expectedDecimalSymbol);
        if (normalizedValue === '') {
            return '';
        }
        if (decimalSymbol === DECIMAL_NOT_SUPPORTED) {
            var roundedAmount = parseFloat(normalizedValue).toFixed(0);
            return roundedAmount + "." + DECIMAL_VALUE_FOR_CURRENCIES_WITHOUT_DECIMALS;
        }
        var decimalPlaces = constants_1.currencyDecimalPlaces.get(currencyCode.toUpperCase()) ||
            constants_1.DEFAULT_DECIMAL_PLACES;
        return parseFloat(normalizedValue).toFixed(decimalPlaces);
    };
    I18n.prototype.formatPercentage = function (amount, options) {
        if (options === void 0) { options = {}; }
        return this.formatNumber(amount, tslib_1.__assign({ as: 'percent' }, options));
    };
    I18n.prototype.formatDate = function (date, options) {
        if (options === void 0) { options = {}; }
        var _a = this, locale = _a.locale, defaultTimezone = _a.defaultTimezone;
        var _b = options.timeZone, timeZone = _b === void 0 ? defaultTimezone : _b;
        var _c = options || {}, _d = _c.style, style = _d === void 0 ? undefined : _d, formatOptions = tslib_1.__rest(_c, ["style"]);
        if (style) {
            return style === constants_1.DateStyle.Humanize
                ? this.humanizeDate(date, formatOptions)
                : this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, formatOptions), constants_1.dateStyle[style]));
        }
        return dates_1.formatDate(date, locale, tslib_1.__assign(tslib_1.__assign({}, formatOptions), { timeZone: timeZone }));
    };
    I18n.prototype.ordinal = function (amount) {
        var locale = this.locale;
        var group = utilities_1.memoizedPluralRules(locale, { type: 'ordinal' }).select(amount);
        return this.translate(group, { scope: 'ordinal' }, { amount: amount });
    };
    I18n.prototype.weekStartDay = function (argCountry) {
        var country = argCountry || this.defaultCountry;
        if (!country) {
            throw new errors_1.MissingCountryError('weekStartDay() cannot be called without a country code.');
        }
        return constants_1.WEEK_START_DAYS.get(country) || constants_1.DEFAULT_WEEK_START_DAY;
    };
    I18n.prototype.getCurrencySymbolLocalized = function (locale, currency) {
        return utilities_1.getCurrencySymbol(locale, { currency: currency });
    };
    I18n.prototype.formatName = function (firstName, lastName, options) {
        if (!firstName) {
            return lastName || '';
        }
        if (!lastName) {
            return firstName;
        }
        var isFullName = Boolean(options && options.full);
        var customNameFormatter = constants_1.EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) ||
            constants_1.EASTERN_NAME_ORDER_FORMATTERS.get(this.language);
        if (customNameFormatter) {
            return customNameFormatter(firstName, lastName, isFullName);
        }
        if (isFullName) {
            return firstName + " " + lastName;
        }
        return firstName;
    };
    I18n.prototype.hasEasternNameOrderFormatter = function () {
        var easternNameOrderFormatter = constants_1.EASTERN_NAME_ORDER_FORMATTERS.get(this.locale) ||
            constants_1.EASTERN_NAME_ORDER_FORMATTERS.get(this.language);
        return Boolean(easternNameOrderFormatter);
    };
    I18n.prototype.formatCurrencyAuto = function (amount, options) {
        if (options === void 0) { options = {}; }
        // use the short format if we can't determine a currency match, or if the
        // currencies match, use explicit when the currencies definitively do not
        // match.
        var formatShort = options.currency == null ||
            this.defaultCurrency == null ||
            options.currency === this.defaultCurrency;
        return formatShort
            ? this.formatCurrencyShort(amount, options)
            : this.formatCurrencyExplicit(amount, options);
    };
    I18n.prototype.formatCurrencyExplicit = function (amount, options) {
        if (options === void 0) { options = {}; }
        var value = this.formatCurrencyShort(amount, options);
        var isoCode = options.currency || this.defaultCurrency || '';
        if (value.includes(isoCode)) {
            return value;
        }
        return value + " " + isoCode;
    };
    I18n.prototype.formatCurrencyShort = function (amount, options) {
        if (options === void 0) { options = {}; }
        var locale = this.locale;
        var shortSymbol = this.getShortCurrencySymbol(options.currency);
        var adjustedPrecision = options.precision;
        if (adjustedPrecision === undefined) {
            var currency = options.currency || this.defaultCurrency || '';
            adjustedPrecision = constants_1.currencyDecimalPlaces.get(currency.toUpperCase());
        }
        var formattedAmount = utilities_1.memoizedNumberFormatter(locale, tslib_1.__assign({ style: 'decimal', minimumFractionDigits: adjustedPrecision, maximumFractionDigits: adjustedPrecision }, options)).format(amount);
        var formattedWithSymbol = shortSymbol.prefixed
            ? "" + shortSymbol.symbol + formattedAmount
            : "" + formattedAmount + shortSymbol.symbol;
        return amount < 0
            ? "-" + formattedWithSymbol.replace('-', '')
            : formattedWithSymbol;
    };
    // Intl.NumberFormat sometimes annotates the "currency symbol" with a country code.
    // For example, in locale 'fr-FR', 'USD' is given the "symbol" of " $US".
    // This method strips out the country-code annotation, if there is one.
    // (So, for 'fr-FR' and 'USD', the return value would be " $").
    //
    // For other currencies, e.g. CHF and OMR, the "symbol" is the ISO currency code.
    // In those cases, we return the full currency code without stripping the country.
    I18n.prototype.getShortCurrencySymbol = function (currencyCode) {
        if (currencyCode === void 0) { currencyCode = this.defaultCurrency || ''; }
        var currency = currencyCode || this.defaultCurrency || '';
        var regionCode = currency.substring(0, 2);
        var info = this.getCurrencySymbol(currency);
        var shortSymbol = info.symbol.replace(regionCode, '');
        var alphabeticCharacters = /[A-Za-zÀ-ÖØ-öø-ÿĀ-ɏḂ-ỳ]/;
        return alphabeticCharacters.exec(shortSymbol)
            ? info
            : { symbol: shortSymbol, prefixed: info.prefixed };
    };
    I18n.prototype.humanizeDate = function (date, options) {
        if (dates_1.isFutureDate(date)) {
            return this.humanizeFutureDate(date, options);
        }
        else {
            return this.humanizePastDate(date, options);
        }
    };
    I18n.prototype.humanizePastDate = function (date, options) {
        var _a;
        if (dates_1.isLessThanOneMinuteAgo(date)) {
            return this.translate('date.humanize.lessThanOneMinuteAgo');
        }
        if (dates_1.isLessThanOneHourAgo(date)) {
            var now = new Date();
            var minutes = Math.floor((now.getTime() - date.getTime()) / dates_1.TimeUnit.Minute);
            return this.translate('date.humanize.lessThanOneHourAgo', {
                count: minutes,
            });
        }
        var timeZone = (_a = options) === null || _a === void 0 ? void 0 : _a.timeZone;
        var time = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { hour: 'numeric', minute: '2-digit' })).toLocaleLowerCase();
        if (dates_1.isToday(date, timeZone)) {
            return time;
        }
        if (dates_1.isYesterday(date, timeZone)) {
            return this.translate('date.humanize.yesterday', { time: time });
        }
        if (dates_1.isLessThanOneWeekAgo(date)) {
            var weekday = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { weekday: 'long' }));
            return this.translate('date.humanize.lessThanOneWeekAgo', {
                weekday: weekday,
                time: time,
            });
        }
        if (dates_1.isLessThanOneYearAgo(date)) {
            var monthDay = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { month: 'short', day: 'numeric' }));
            return this.translate('date.humanize.lessThanOneYearAgo', {
                date: monthDay,
                time: time,
            });
        }
        return this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { style: constants_1.DateStyle.Short }));
    };
    I18n.prototype.humanizeFutureDate = function (date, options) {
        var _a;
        var timeZone = (_a = options) === null || _a === void 0 ? void 0 : _a.timeZone;
        var time = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { hour: 'numeric', minute: '2-digit' })).toLocaleLowerCase();
        if (dates_1.isToday(date, timeZone)) {
            return this.translate('date.humanize.today', { time: time });
        }
        if (dates_1.isTomorrow(date, timeZone)) {
            return this.translate('date.humanize.tomorrow', { time: time });
        }
        if (dates_1.isLessThanOneWeekAway(date)) {
            var weekday = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { weekday: 'long' }));
            return this.translate('date.humanize.lessThanOneWeekAway', {
                weekday: weekday,
                time: time,
            });
        }
        if (dates_1.isLessThanOneYearAway(date)) {
            var monthDay = this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { month: 'short', day: 'numeric' }));
            return this.translate('date.humanize.lessThanOneYearAway', {
                date: monthDay,
                time: time,
            });
        }
        return this.formatDate(date, tslib_1.__assign(tslib_1.__assign({}, options), { style: constants_1.DateStyle.Short }));
    };
    I18n.prototype.currencyDecimalSymbol = function (currencyCode) {
        var digitOrSpace = /\s|\d/g;
        var symbol = this.getCurrencySymbolLocalized(this.locale, currencyCode).symbol;
        var templatedInput = 1;
        var decimal = this.formatCurrency(templatedInput, {
            currency: currencyCode,
        })
            .replace(symbol, '')
            .replace(digitOrSpace, '');
        return decimal.length === 0 ? DECIMAL_NOT_SUPPORTED : decimal;
    };
    I18n.prototype.numberSymbols = function () {
        var e_1, _a;
        var formattedNumber = this.formatNumber(123456.7, {
            maximumFractionDigits: 1,
            minimumFractionDigits: 1,
        });
        var thousandSymbol;
        var decimalSymbol;
        try {
            for (var formattedNumber_1 = tslib_1.__values(formattedNumber), formattedNumber_1_1 = formattedNumber_1.next(); !formattedNumber_1_1.done; formattedNumber_1_1 = formattedNumber_1.next()) {
                var char = formattedNumber_1_1.value;
                if (isNaN(parseInt(char, 10))) {
                    if (thousandSymbol)
                        decimalSymbol = char;
                    else
                        thousandSymbol = char;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (formattedNumber_1_1 && !formattedNumber_1_1.done && (_a = formattedNumber_1.return)) _a.call(formattedNumber_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { thousandSymbol: thousandSymbol, decimalSymbol: decimalSymbol };
    };
    tslib_1.__decorate([
        decorators_1.memoize()
    ], I18n.prototype, "numberSymbols", null);
    return I18n;
}());
exports.I18n = I18n;
function normalizedNumber(input, expectedDecimal, usesPeriodThousandSymbol) {
    var nonDigits = /\D/g;
    // For locales that use non-period symbols as the decimal symbol, users may still input a period
    // and expect it to be treated as the decimal symbol for their locale.
    var hasExpectedDecimalSymbol = input.lastIndexOf(expectedDecimal) !== -1;
    var hasPeriodAsDecimal = input.lastIndexOf(PERIOD) !== -1;
    var usesPeriodDecimal = !usesPeriodThousandSymbol &&
        !hasExpectedDecimalSymbol &&
        hasPeriodAsDecimal;
    var decimalSymbolToUse = usesPeriodDecimal ? PERIOD : expectedDecimal;
    var lastDecimalIndex = input.lastIndexOf(decimalSymbolToUse);
    var integerValue = input
        .substring(0, lastDecimalIndex)
        .replace(nonDigits, '');
    var decimalValue = input
        .substring(lastDecimalIndex + 1)
        .replace(nonDigits, '');
    var normalizedDecimal = lastDecimalIndex === -1 ? '' : PERIOD;
    var normalizedValue = "" + integerValue + normalizedDecimal + decimalValue;
    return normalizedValue === '' || normalizedValue === PERIOD
        ? ''
        : normalizedValue;
}
function isTranslateOptions(object) {
    return 'scope' in object;
}
function defaultOnError(error) {
    throw error;
}
