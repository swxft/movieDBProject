"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_1 = tslib_1.__importDefault(require("react"));
var react_hooks_1 = require("@shopify/react-hooks");
var i18n_1 = require("./i18n");
var context_1 = require("./context");
function useI18n(options) {
    var manager = react_1.default.useContext(context_1.I18nContext);
    if (manager == null) {
        throw new Error('Missing i18n manager. Make sure to use an <I18nContext.Provider /> somewhere in your React tree.');
    }
    var registerOptions = react_1.default.useRef(options);
    if (shouldRegister(registerOptions.current) !== shouldRegister(options)) {
        throw new Error('You switched between providing registration options and not providing them, which is not supported.');
    }
    // Yes, this would usually be dangerous. But just above this line, we check to make
    // sure that they never switch from the case where `options == null` to `options != null`,
    // so we know that a given use of this hook will only ever hit one of these two cases.
    /* eslint-disable react-hooks/rules-of-hooks */
    if (options == null) {
        return useSimpleI18n(manager);
    }
    else {
        return useComplexI18n(options, manager);
    }
    /* eslint-enable react-hooks/rules-of-hooks */
}
exports.useI18n = useI18n;
function useComplexI18n(_a, manager) {
    var id = _a.id, fallback = _a.fallback, translations = _a.translations;
    var managerRef = react_1.default.useRef(null);
    var unsubscribeRef = react_1.default.useRef(noop);
    var parentIds = react_1.default.useContext(context_1.I18nIdsContext);
    // Parent IDs can only change when a parent gets added/ removed,
    // which would cause the component using `useI18n` to unmount.
    // We also don't support the `id` changing between renders. For these
    // reasons, it's safe to just store the IDs once and never let them change.
    var ids = react_hooks_1.useLazyRef(function () { return (id ? tslib_1.__spread([id], parentIds) : parentIds); });
    // When the manager changes, we need to do the following IMMEDIATELY (i.e.,
    // not in a useEffect callback):
    //
    // 1. Register the componentâ€™s translations. This ensures that the first render gets
    //    the synchronous translations, if available.
    // 2. Unsubscribe from changes to a previous manager.
    // 3. Subscribe to changes from the new manager. This ensures that if the subscription
    //    is updated between render and `useEffect`, the state update is not lost.
    if (manager !== managerRef.current) {
        managerRef.current = manager;
        unsubscribeRef.current();
        unsubscribeRef.current = manager.subscribe(ids.current, function (_a, details) {
            var translations = _a.translations, loading = _a.loading;
            var newI18n = new i18n_1.I18n(translations, tslib_1.__assign(tslib_1.__assign({}, details), { loading: loading }));
            i18nRef.current = newI18n;
            setI18n(newI18n);
        });
        if (id && (translations || fallback)) {
            manager.register({ id: id, translations: translations, fallback: fallback });
        }
    }
    var _b = tslib_1.__read(react_1.default.useState(function () {
        var managerState = manager.state(ids.current);
        var translations = managerState.translations, loading = managerState.loading;
        return new i18n_1.I18n(translations, tslib_1.__assign(tslib_1.__assign({}, manager.details), { loading: loading }));
    }), 2), i18n = _b[0], setI18n = _b[1];
    var i18nRef = react_1.default.useRef(i18n);
    react_1.default.useEffect(function () {
        return unsubscribeRef.current;
    }, []);
    // We use refs in this component so that it never changes. If this component
    // is regenerated, it will unmount the entire tree of the previous component,
    // which is usually not desirable. Technically, this does leave surface area
    // for a bug to sneak in: if the component that renders this does so inside
    // a component that blocks the update from passing down, nothing will force
    // this component to re-render, so no descendants will get the new ids/ i18n
    // value. Because we don't actually have any such cases, we're OK with this
    // for now.
    var shareTranslationsComponent = react_hooks_1.useLazyRef(function () {
        return function ShareTranslations(_a) {
            var children = _a.children;
            return (react_1.default.createElement(context_1.I18nIdsContext.Provider, { value: ids.current },
                react_1.default.createElement(context_1.I18nParentContext.Provider, { value: i18nRef.current }, children)));
        };
    });
    return [i18n, shareTranslationsComponent.current];
}
function useSimpleI18n(manager) {
    var i18n = react_1.default.useContext(context_1.I18nParentContext) || new i18n_1.I18n([], manager.details);
    return [i18n, IdentityComponent];
}
function IdentityComponent(_a) {
    var children = _a.children;
    return react_1.default.createElement(react_1.default.Fragment, null, children);
}
function shouldRegister(_a) {
    var _b = _a === void 0 ? {} : _a, fallback = _b.fallback, translations = _b.translations;
    return fallback != null || translations != null;
}
function noop() { }
